use std::{
    fs::File,
    io::Write,
    path::PathBuf,
    time::{SystemTime, UNIX_EPOCH, Duration},
};
use axum::extract::Multipart;
use tokio::process::Command as TokioCommand;
use tokio::time::timeout;
use crate::{config::Config, services::decoder_service::ServiceError};

pub struct FileProcessor {
    config: Config,
}

impl FileProcessor {
    pub fn new(config: Config) -> Self {
        Self { config }
    }

    pub async fn process_upload(&self, mut multipart: Multipart) -> Result<PathBuf, ServiceError> {
        let temp_dir = self.config.temp_dir();
        
        // Clean up previous temp files
        crate::config::cleanup_temp_files(&temp_dir)?;

        while let Some(field) = multipart
            .next_field()
            .await
            .map_err(|_| ServiceError::InvalidInput("Invalid multipart data".to_string()))?
        {
            if let Some(filename) = field.file_name() {
                let now = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_millis();
                let temp_filename = format!("{}_{}", now, filename);
                let filepath = temp_dir.join(&temp_filename);
                
                let data = field
                    .bytes()
                    .await
                    .map_err(|_| ServiceError::InvalidInput("Failed to read file data".to_string()))?;
                
                let mut file = File::create(&filepath)?;
                file.write_all(&data)?;
                
                return Ok(filepath);
            }
        }
        
        Err(ServiceError::InvalidInput("No file found in upload".to_string()))
    }

    pub async fn run_decoder(&self, input_file: &PathBuf, firmware_version: &str, log_level: &str) -> Result<String, ServiceError> {
        // Use the firmware version to find the corresponding dictionary file in downloads
        let dict_filename = format!("{}.log", firmware_version);
        let dict_path = self.config.downloads_dir().join(&dict_filename);
        
        // Check if dictionary file exists
        if !dict_path.exists() {
            return Err(ServiceError::NotFound(format!("Dictionary file '{}' not found in downloads", dict_filename)));
        }
        
        // Use the standalone log_decoder program
        let decoder_path = PathBuf::from("/usr/local/bin/log_decoder");
        
        // Check if decoder exists
        if !decoder_path.exists() {
            return Err(ServiceError::NotFound("Log decoder program not found".to_string()));
        }
        
        tracing::info!("Starting log decoder execution with dictionary: {} and log level {}", dict_filename, log_level);
        
        // Run log_decoder with timeout (30 minutes max) and capture output directly
        let mut command = TokioCommand::new(&decoder_path);
        command
            .arg(input_file.to_str().unwrap())  // binary syslog file
            .arg("-d")
            .arg(dict_path.to_str().unwrap())   // dictionary file
            .arg("-l")
            .arg(log_level)                     // log level
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped());

        tracing::info!("Log decoder process spawned, waiting for completion...");

        // Set timeout to 30 minutes for large files
        let timeout_duration = Duration::from_secs(30 * 60);
        
        let result = timeout(timeout_duration, command.output()).await;
        
        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                
                tracing::info!("Log decoder completed. Exit status: {}, stdout length: {}, stderr length: {}", 
                              output.status, stdout.len(), stderr.len());
                
                if !output.status.success() {
                    tracing::error!("Log decoder failed with error: {}", stderr);
                    return Err(ServiceError::InvalidInput(format!("Log decoder error: {}", stderr)));
                }
                
                // Return stdout content, or stderr if stdout is empty
                if !stdout.is_empty() {
                    Ok(stdout.to_string())
                } else if !stderr.is_empty() {
                    tracing::warn!("No stdout output, returning stderr content");
                    Ok(stderr.to_string())
                } else {
                    tracing::warn!("No output from decoder");
                    Ok("No output generated by decoder".to_string())
                }
            }
            Ok(Err(e)) => {
                tracing::error!("Decoder process error: {}", e);
                Err(ServiceError::IoError(e))
            }
            Err(_) => {
                tracing::error!("Log decoder process timed out after 30 minutes");
                Err(ServiceError::InvalidInput("Log decoder process timed out. The file might be too large or corrupted.".to_string()))
            }
        }
    }
}
